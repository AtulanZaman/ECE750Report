\section{Introduction}
%Goodness(Cite immutability sideeffects)
Object immutability is a feature of object oriented programming that restricts objects from being mutated after they are instantiated. This is generally a recommended practice because of simplicity and safety of programs to prevent bugs. Object immutability comes in different forms. One of the forms is variable immutability. In Java for example, this is enforced by declaring variables as \texttt{final} so that it can only be set during object construction and cannot be mutated afterwards using mutator method. Second form of immutability is reference immutability. This ensures that external methods referencing to a mutable parameter does not have permissions to mutate the parameter. There is much research aimed at enforcing this form immutability, most notably the work of Huang et.\ al \citep{ref:ReIm} in creating a type system to ensure reference immutability when the referenced object is stored in a local variable. The work of Tschantz et. al on the tool \textit{Javari} \cite{ref:javari} is another research tool that helps programmers enforce reference immutability. At the class level, an object can be declared to be mutable if two design choices are maintained. Firstly, all the attributes of the class are declared to be immutable during declaration. Secondly all the mutator methods of the class retain the immutable nature of the object by creating a different instance of the object with the mutated attribute and returning that object instead of directly mutating the instance. 

This is generally desirable because that causes methods sharing the object to not behave erroneously. Another application of this is in concurrent programming where threads sharing objects will have their own instances of the object. However, sometimes this causes overhead because everytime an object needs to be mutated, the a new instance has to be reconstructed from the existing instance. It is a standard safety vs performance tradeoff in software engineering. For large instance manipulation such as in manipulating abstract syntax tree construction in compilers this causes high memory and performance footprint during the construction process. Due to safety recommendations of object oriented programming, programmer usual choose to make object instances immutable to ensure safety of execution. However in cases of object sharing, infered using escape analysis \citep{ref:compositionalEscape}\cite{ref:escapejava}\cite{ref:incrementalescape} it is provable that program safety can be ensure without enforcing object immutability. The work of this project focuses on using intra-procedural escape analysis techniques \cite{ref:Kotzmann} to detect cases where it is safe make objects mutable without any side effects.

This techniques uses intra-procedural dataflow analysis using object representatives \citep{ref:or} detect locals and references that share a common heap pointer. Object representatives is a technique for detecting variables that share the same heap pointer, although they have different stack pointers, without doing inter-procedural analysis. After the object representative mapping is created using a may alias analysis, our escape analysis heuristics are used to analyze program points to detect locals and references that might have escaped. The intra-procedural analysis in this project is implemented using the Soot framework for Java bytecode analysis \citep{ref:Soot}.

Much of program analysis research has been focused on detecting lack of immutability in program to detect potential sources of bugs and problems. Some work has been done on creating type systems to detect variables that behave like immutable although they are not declared as \texttt{final}\cite{ref:finalinference}. This work in a way is going against the flow of traditional research in the sense that it tries to escape from the paranoia of safety by trying to make immutable objects immutable.

%Related works(Cite javari, ReimInfer etc)
%Where does it fit in
%Analysis used(Cite Escape Analysis)
%Implementation(Cite Soot)
%Flow of the document
